// LegalShuffleCam ‚Ä¢ rtc-core.js (version finale optimis√©e pour mobile)
// Gestion compl√®te de WebRTC avec :
// - Filtrage des codecs (exclusion AV1)
// - Tampon ICE robuste pour mobile
// - Logs d√©taill√©s pour le d√©bogage
// - Gestion des erreurs et reconnexions

// --- Configuration WebRTC ---
const RTC_CONFIG = {
  iceServers: [
    { urls: 'stun:stun.l.google.com:19302' },
    { urls: 'stun:stun1.l.google.com:19302' },
    { urls: 'stun:stun2.l.google.com:19302' }
  ],
  // Force le plan unifi√© pour une meilleure compatibilit√©
  sdpSemantics: 'unified-plan'
};

// --- Variables globales ---
let localStream = null;
let peerConnection = null;
let remoteId = null;
let socket = null;
let iceBuffer = [];          // Tampon pour les candidats ICE
let partnerSocketId = null; // ID du partenaire pour l'envoi des ICE
let iceSentCount = 0;        // Compteur de candidats envoy√©s
let iceBufferedCount = 0;    // Compteur de candidats bufferis√©s
let lastIceCandidateTime = 0; // Timestamp du dernier candidat ICE

// --- Filtrage du SDP (exclusion AV1, priorit√© VP8) ---
function filterSDP(sdp) {
  if (!sdp) return sdp;

  // 1. Supprime les lignes AV1 (non support√© sur certains mobiles)
  let filteredSDP = sdp
    .replace(/a=rtpmap:(\d+) AV1\/90000[\s\S]*?(?=\r\n|$)/g, '')
    .replace(/a=fmtp:(\d+) apt=\1\r\n/g, '')
    .replace(/a=rtcp-fb:(\d+) ccm fir\r\n/g, '');

  // 2. Donne la priorit√© √† VP8 (meilleur support mobile)
  filteredSDP = filteredSDP.replace(
    /(a=rtpmap:(\d+) VP8\/90000)/g,
    'a=rtpmap:$2 VP8/90000\r\n' +
    'a=fmtp:$2 profile-level-id=0;x-google-start-bitrate=1000'
  );

  // 3. Limite les codecs audio √† Opus (meilleur support)
  filteredSDP = filteredSDP.replace(
    /(m=audio.*\r\n)(?!.*opus)/g,
    '$1a=rtpmap:111 opus/48000/2\r\n' +
    'a=fmtp:111 minptime=10;useinbandfec=1\r\n' +
    'a=rtcp-fb:111 transport-cc\r\n'
  );

  return filteredSDP;
}

// --- Gestion des candidats ICE ---
function sendIce(candidate) {
  if (!candidate) {
    console.warn("[RTC-ICE] Candidat ICE invalide ignor√©.");
    return;
  }

  lastIceCandidateTime = Date.now();

  if (partnerSocketId) {
    socket.emit("ice-candidate", { to: partnerSocketId, candidate });
    iceSentCount++;
    console.log(`[RTC-ICE] ‚úÖ Candidat ICE envoy√© √† ${partnerSocketId} (total: ${iceSentCount})`);
  } else {
    iceBuffer.push(candidate);
    iceBufferedCount++;
    console.log(`[RTC-ICE] ‚è≥ Candidat ICE bufferis√© (total: ${iceBufferedCount}, tampon: ${iceBuffer.length})`);
  }
}

function flushIceBuffer() {
  if (!partnerSocketId) {
    console.warn("[RTC-ICE] ‚ö† Impossible de vider le tampon : partnerSocketId non d√©fini.");
    return;
  }

  if (iceBuffer.length === 0) {
    console.log("[RTC-ICE] üóë Tampon ICE d√©j√† vide.");
    return;
  }

  console.log(`[RTC-ICE] üì§ Vidage du tampon : ${iceBuffer.length} candidats vers ${partnerSocketId}`);
  iceBuffer.forEach(candidate => {
    socket.emit("ice-candidate", { to: partnerSocketId, candidate });
    iceSentCount++;
  });
  iceBuffer = [];
  iceBufferedCount = 0;
}

// --- Initialisation du flux local ---
async function initLocalStream() {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({
      video: {
        width: { ideal: 640 },
        height: { ideal: 480 },
        frameRate: { ideal: 30 },
        facingMode: 'user',
        // Force VP8 sur mobile (meilleur support)
        codec: 'vp8'
      },
      audio: {
        echoCancellation: true,
        noiseSuppression: true,
        // Force Opus (meilleur codec audio pour WebRTC)
        codec: 'opus'
      }
    });

    localStream = stream;
    console.log("[RTC] üé• Flux local pr√™t (VP8/Opus).");
    return stream;
  } catch (err) {
    console.error("[RTC] ‚ùå Erreur cam√©ra/micro :", err);
    window.dispatchEvent(new CustomEvent('rtcError', {
      detail: { message: "Acc√®s cam√©ra/micro impossible.", error: err }
    }));
    throw err;
  }
}

// --- Cr√©ation de la connexion WebRTC ---
function createPeerConnection(stream) {
  if (!stream) {
    console.error("[RTC] ‚ùå Flux local manquant.");
    return null;
  }

  const pc = new RTCPeerConnection(RTC_CONFIG);

  // Ajoute les tracks locaux
  stream.getTracks().forEach(track => {
    if (track.kind === 'video') {
      console.log(`[RTC] üìπ Track vid√©o ajout√© (${track.id}, ${track.kind}).`);
    } else if (track.kind === 'audio') {
      console.log(`[RTC] üé§ Track audio ajout√© (${track.id}, ${track.kind}).`);
    }
    pc.addTrack(track, stream);
  });

  // Gestion des candidats ICE
  pc.onicecandidate = (event) => {
    if (event.candidate) {
      sendIce(event.candidate);
    } else {
      console.log("[RTC-ICE] üèÅ Tous les candidats ICE g√©n√©r√©s.");
    }
  };

  // Gestion des tracks distants
  pc.ontrack = (event) => {
    const remoteVideo = document.getElementById("remoteVideo");
    if (!remoteVideo) {
      console.error("[RTC] ‚ùå √âl√©ment remoteVideo introuvable.");
      return;
    }

    const stream = event.streams?.[0] || new MediaStream([event.track]);
    remoteVideo.srcObject = stream;

    // Contourne les restrictions autoplay sur mobile
    const playPromise = remoteVideo.play();
    if (playPromise !== undefined) {
      playPromise.catch(err => {
        console.warn("[RTC] ‚ö† Lecture bloqu√©e par autoplay :", err);
        // Solution de contournement pour mobile
        remoteVideo.muted = true;
        remoteVideo.play().catch(() => {});
      });
    }

    console.log("[RTC] üé• Flux distant attach√©.", {
      readyState: remoteVideo.readyState,
      trackKind: event.track.kind,
      codec: event.track.getSettings().codec || 'inconnu'
    });

    // √âcoute les changements d'√©tat
    remoteVideo.onloadedmetadata = () => {
      console.log("[RTC] üì° M√©tadonn√©es charg√©es. √âtat :", remoteVideo.readyState);
    };
  };

  // Gestion des erreurs
  pc.oniceconnectionstatechange = () => {
    console.log(`[RTC] üîÑ √âtat ICE : ${pc.iceConnectionState}`);
    if (pc.iceConnectionState === 'failed') {
      console.error("[RTC] ‚ùå √âchec de la connexion ICE.");
      window.dispatchEvent(new CustomEvent('rtcFailed'));
    }
  };

  pc.onconnectionstatechange = () => {
    console.log(`[RTC] üîÑ √âtat connexion : ${pc.connectionState}`);
    if (pc.connectionState === 'connected') {
      console.log("[RTC] ‚úÖ Connexion WebRTC √©tablie.");
      window.dispatchEvent(new CustomEvent('rtcConnected'));
    } else if (pc.connectionState === 'failed') {
      console.error("[RTC] ‚ùå √âchec de la connexion WebRTC.");
      window.dispatchEvent(new CustomEvent('rtcFailed'));
    }
  };

  return pc;
}

// --- Appel sortant (offer) ---
async function startCall(partnerId) {
  console.log(`[RTC] üìû Appel vers ${partnerId}`);
  if (!partnerId || typeof partnerId !== 'string') {
    console.error("[RTC] ‚ùå partnerId invalide :", partnerId);
    return;
  }

  try {
    if (!localStream) {
      localStream = await initLocalStream();
      document.getElementById("localVideo").srcObject = localStream;
    }

    remoteId = partnerId;
    partnerSocketId = partnerId;
    window.lastRTCPartnerId = partnerId;

    // Vidage du tampon ICE si des candidats √©taient en attente
    if (iceBuffer.length > 0) {
      console.log(`[RTC-ICE] üì§ Vidage du tampon ICE (${iceBuffer.length} candidats).`);
      flushIceBuffer();
    }

    peerConnection = createPeerConnection(localStream);
    const offer = await peerConnection.createOffer({
      offerToReceiveAudio: true,
      offerToReceiveVideo: true
    });

    // Filtrage du SDP pour exclure AV1 et prioriser VP8
    offer.sdp = filterSDP(offer.sdp);
    await peerConnection.setLocalDescription(offer);

    console.log(`[RTC] üì§ Offre envoy√©e √† ${partnerId} (codecs: VP8/Opus).`);
    socket.emit("offer", { to: partnerId, sdp: offer });
  } catch (err) {
    console.error("[RTC] ‚ùå Erreur startCall :", err);
    window.dispatchEvent(new CustomEvent('rtcError', {
      detail: { message: "√âchec de l'appel sortant.", error: err }
    }));
  }
}

// --- R√©ception d'une offre (answer) ---
async function handleOffer(data) {
  if (!data?.sdp || !data?.from) {
    console.error("[RTC] ‚ùå Donn√©es d'offre invalides :", data);
    return;
  }

  try {
    if (!localStream) {
      localStream = await initLocalStream();
      document.getElementById("localVideo").srcObject = localStream;
    }

    remoteId = data.from;
    partnerSocketId = data.from;
    window.lastRTCPartnerId = data.from;

    // Vidage du tampon ICE si des candidats √©taient en attente
    if (iceBuffer.length > 0) {
      console.log(`[RTC-ICE] üì§ Vidage du tampon ICE (${iceBuffer.length} candidats).`);
      flushIceBuffer();
    }

    peerConnection = createPeerConnection(localStream);
    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.sdp));

    // Log des codecs n√©goci√©s
    peerConnection.getReceivers().forEach(receiver => {
      if (receiver.track) {
        console.log(`[RTC] üì° Codec n√©goci√© (${receiver.track.kind}):`,
                    receiver.track.getSettings().codec || 'inconnu');
      }
    });

    const answer = await peerConnection.createAnswer();
    answer.sdp = filterSDP(answer.sdp);
    await peerConnection.setLocalDescription(answer);

    console.log(`[RTC] üì§ R√©ponse envoy√©e √† ${data.from} (VP8/Opus).`);
    socket.emit("answer", { to: data.from, sdp: answer });
  } catch (err) {
    console.error("[RTC] ‚ùå Erreur handleOffer :", err);
    window.dispatchEvent(new CustomEvent('rtcError', {
      detail: { message: "√âchec de la r√©ponse WebRTC.", error: err }
    }));
  }
}

// --- R√©ception d'une r√©ponse (answer) ---
async function handleAnswer(data) {
  if (!data?.sdp || !peerConnection) {
    console.error("[RTC] ‚ùå Donn√©es de r√©ponse invalides :", data);
    return;
  }

  try {
    // Filtrage du SDP avant application
    const filteredSDP = filterSDP(data.sdp);
    await peerConnection.setRemoteDescription(new RTCSessionDescription(filteredSDP));

    // Log des codecs n√©goci√©s
    peerConnection.getReceivers().forEach(receiver => {
      if (receiver.track) {
        console.log(`[RTC] üì° Codec final (${receiver.track.kind}):`,
                    receiver.track.getSettings().codec || 'inconnu');
      }
    });
  } catch (err) {
    console.error("[RTC] ‚ùå Erreur handleAnswer :", err);
    window.dispatchEvent(new CustomEvent('rtcError', {
      detail: { message: "√âchec de l'application de la r√©ponse.", error: err }
    }));
  }
}

// --- R√©ception d'un candidat ICE ---
async function handleICECandidate(data) {
  if (!data?.candidate || !peerConnection) {
    console.warn("[RTC] ‚ö† Candidat ICE invalide ou peerConnection absente :", data);
    return;
  }

  try {
    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
    console.log("[RTC] üèó Candidat ICE ajout√© avec succ√®s.");
  } catch (err) {
    console.error("[RTC] ‚ùå Erreur ajout candidat ICE :", err);
  }
}

// --- D√©connexion WebRTC ---
function disconnectWebRTC() {
  if (peerConnection) {
    peerConnection.getSenders().forEach(sender => {
      if (sender.track) sender.track.stop();
    });
    peerConnection.close();
    peerConnection = null;
    console.log("[RTC] üîå Connexion WebRTC ferm√©e.");
  }

  if (localStream) {
    localStream.getTracks().forEach(track => track.stop());
    localStream = null;
    console.log("[RTC] üé• Flux local arr√™t√©.");
  }

  remoteId = null;
  partnerSocketId = null;
  iceBuffer = [];
  iceSentCount = 0;
  iceBufferedCount = 0;

  window.dispatchEvent(new CustomEvent('rtcDisconnected'));
}

// --- √âcouteur pour l'√©v√©nement "partner" ---
function setupPartnerListener() {
  socket.on("partner", (data) => {
    if (!data?.id) {
      console.error("[RTC] ‚ùå Donn√©es partenaire invalides :", data);
      return;
    }

    partnerSocketId = data.id;
    remoteId = data.id;
    window.lastRTCPartnerId = data.id;

    console.log(`[RTC] ü§ù Partenaire re√ßu : ${partnerSocketId}`);

    // Vidage du tampon ICE si des candidats √©taient en attente
    if (iceBuffer.length > 0) {
      console.log(`[RTC-ICE] üì§ Vidage du tampon ICE (${iceBuffer.length} candidats).`);
      flushIceBuffer();
    } else {
      console.log("[RTC-ICE] üóë Tampon ICE vide, aucun candidat √† envoyer.");
    }
  });
}

// --- Initialisation Socket.IO ---
function initSocket() {
  socket = io();

  socket.on("connect", () => {
    console.log(`[SOCKET] ‚úÖ Connect√© (id: ${socket.id}).`);
  });

  socket.on("disconnect", (reason) => {
    console.log(`[SOCKET] ‚ùå D√©connect√© (raison: ${reason}).`);
    window.dispatchEvent(new CustomEvent('rtcError', {
      detail: { message: `D√©connect√© : ${reason}` }
    }));
  });

  socket.on("connect_error", (err) => {
    console.error("[SOCKET] ‚ö† Erreur de connexion :", err);
    window.dispatchEvent(new CustomEvent('rtcError', {
      detail: { message: "Erreur Socket.IO", error: err }
    }));
  });

  // Configuration des √©couteurs
  setupPartnerListener();
  socket.on("offer", handleOffer);
  socket.on("answer", handleAnswer);
  socket.on("ice-candidate", handleICECandidate);
}

// --- Exports globaux ---
window.initLocalStream = initLocalStream;
window.startCall = startCall;
window.handleOffer = handleOffer;
window.handleAnswer = handleAnswer;
window.handleICECandidate = handleICECandidate;
window.disconnectWebRTC = disconnectWebRTC;
window.initSocket = initSocket;
